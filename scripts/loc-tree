#!/usr/bin/env python3
import argparse
import collections
import json
import os
import shutil
import subprocess
import sys
from pathlib import Path

# --- Configuration ---
WIDTH = 80
HEADER = ("Package", "Code")
LANG_ALIASES = {
    "py": "Python",
    "go": "Go",
    "rs": "Rust",
    "ts": "TypeScript",
    "tsx": "TSX",
    "js": "JavaScript",
    "jsx": "JSX",
    "java": "Java",
    "kt": "Kotlin",
    "c": "C",
    "h": "C Header",
    "cpp": "C++",
    "hpp": "C++ Header",
    "cs": "C#",
    "rb": "Ruby",
    "php": "PHP",
    "swift": "Swift",
    "scala": "Scala",
    "pl": "Perl",
}
TEST_DIR_NAMES = {"test", "tests"}
TEST_FILE_PATTERNS = {"test_", "_test"}

# --- Core Logic ---

def die(message):
    """Prints an error message to stderr and exits."""
    print(f"Error: {message}", file=sys.stderr)
    sys.exit(1)

def run_tokei(path):
    """Runs tokei on the given path and returns the parsed JSON output."""
    if not shutil.which("tokei"):
        die("`tokei` command not found. Please install it first.")

    command = ["tokei", "--output", "json", str(path)]
    try:
        result = subprocess.run(
            command, capture_output=True, text=True, check=True
        )
        return json.loads(result.stdout)
    except FileNotFoundError:
        die("`tokei` command not found, though it seemed to exist.")
    except subprocess.CalledProcessError as e:
        die(f"`tokei` failed with exit code {e.returncode}:\n{e.stderr}")
    except json.JSONDecodeError:
        die("Failed to parse JSON output from `tokei`.")

def is_test_file(path):
    """Determines if a file is a test file based on heuristics."""
    path_lower = str(path).lower()
    
    # Check parent directories for 'test' or 'tests'
    for part in path.parts:
        if part.lower() in TEST_DIR_NAMES:
            return True
            
    # Check file name for test patterns
    name_lower = path.name.lower()
    for pattern in TEST_FILE_PATTERNS:
        if pattern in name_lower:
            return True
            
    return False

def parse_and_filter_tokei(json_data, root_path, with_tests):
    """
    Parses tokei JSON, categorizes code/tests, and returns stats.
    - dir_stats: {dir_path: {language: {'code': loc, 'test': loc}}}
    - file_stats: {dir_path: {language: {file_name: {'code': loc, 'test': loc}}}}
    """
    dir_stats = collections.defaultdict(lambda: collections.defaultdict(lambda: collections.defaultdict(int)))
    file_stats = collections.defaultdict(lambda: collections.defaultdict(lambda: collections.defaultdict(lambda: collections.defaultdict(int))))

    for language, reports in json_data.items():
        if language == "Total":
            continue
        for report in reports["reports"]:
            file_path = root_path / Path(report["name"])
            code_lines = report["stats"]["code"]
            if code_lines == 0:
                continue

            is_test = is_test_file(file_path)
            
            if not with_tests and is_test:
                continue

            code_type = "test" if is_test else "code"
            parent_dir = file_path.parent
            
            dir_stats[parent_dir][language][code_type] += code_lines
            file_stats[parent_dir][language][file_path.name][code_type] = code_lines

    return dir_stats, file_stats

def determine_language(stats, user_lang):
    """
    Determines the language to display, either from user input or by
    finding the most common one.
    """
    if user_lang:
        user_lang_lower = user_lang.lower()
        # Return the proper case if it's a direct match, e.g., user enters "python"
        for key, val in LANG_ALIASES.items():
            if user_lang_lower == val.lower():
                return val
        return LANG_ALIASES.get(user_lang_lower, user_lang.capitalize())

    # Find the top language by total lines of code
    language_totals = collections.Counter()
    for dir_langs in stats.values():
        for lang, code_types in dir_langs.items():
            if code_types['code'] > 0:
                language_totals[lang] += code_types['code']
    
    if not language_totals:
        return "N/A"
        
    return language_totals.most_common(1)[0][0]

def format_output(dir_stats, file_stats, language, root_path, tree_view, with_files, with_tests, output_mode):
    """Formats and prints the final report."""
    separator = "â”€" * WIDTH

    # --- Column Widths ---
    code_width = 12
    test_width = 12 if with_tests else 0

    def format_val(value):
        """Formats a number, returning '-' if the value is 0."""
        return f"{value:,}" if value > 0 else "-"

    # --- Data Aggregation ---
    dir_totals = collections.defaultdict(lambda: collections.defaultdict(int))
    files_only = collections.defaultdict(lambda: collections.defaultdict(int))

    for path, lang_stats in dir_stats.items():
        stats = lang_stats.get(language, {})
        files_only[path]['code'] = stats.get('code', 0)
        if with_tests:
            files_only[path]['test'] = stats.get('test', 0)

    all_paths = sorted(files_only.keys(), key=lambda p: len(p.parts), reverse=True)
    for path in all_paths:
        dir_totals[path]['code'] += files_only[path]['code']
        if with_tests:
            dir_totals[path]['test'] += files_only[path]['test']
        
        parent = path.parent
        if parent != path:
             dir_totals[parent]['code'] += dir_totals[path]['code']
             if with_tests:
                dir_totals[parent]['test'] += dir_totals[path]['test']

    # --- Determine which directories to display ---
    all_display_paths = sorted([
        p for p in dir_totals 
        if p.is_relative_to(root_path) and (dir_totals[p]['code'] > 0 or dir_totals[p].get('test', 0) > 0)
    ])

    if tree_view:
        display_paths = all_display_paths
    else:
        display_paths = [p for p in all_display_paths if p == root_path or p.parent == root_path]

    # --- Printing ---
    print(separator)
    # Header
    if with_tests:
        header_label = "Package"
        header_test = "Tests"
        header_code = "Code"
        padding = ' ' * (WIDTH - len(header_label) - test_width - code_width)
        print(f"{header_label}{padding}{header_test:>{test_width}}{header_code:>{code_width}}")
    else:
        header_label = "Package"
        header_code = "Code"
        padding = ' ' * (WIDTH - len(header_label) - code_width)
        print(f"{header_label}{padding}{header_code:>{code_width}}")
    print(separator)

    for path in display_paths:
        totals = dir_totals[path]
        
        if path == root_path:
            indent_level = 0
            display_name = os.path.basename(os.path.normpath(root_path))
            if any(p.parent == root_path for p in display_paths):
                 display_name += "/"
        else:
            indent_level = len(path.relative_to(root_path).parts)
            display_name = path.name + "/"
        indent = "    " * indent_level
        line_label = f"{indent}{display_name}"

        if with_tests:
            test_str = format_val(totals.get('test', 0))
            code_str = format_val(totals.get('code', 0))
            padding = ' ' * max(1, WIDTH - len(line_label) - test_width - code_width)
            print(f"{line_label}{padding}{test_str:>{test_width}}{code_str:>{code_width}}")
        else:
            code_str = format_val(totals.get('code', 0))
            padding = ' ' * max(1, WIDTH - len(line_label) - code_width)
            print(f"{line_label}{padding}{code_str:>{code_width}}")

        if with_files:
            files = file_stats.get(path, {}).get(language, {})
            for file_name, stats in sorted(files.items()):
                file_label = f"{indent}    {file_name}"
                if with_tests:
                    test_str = format_val(stats.get('test', 0))
                    code_str = format_val(stats.get('code', 0))
                    padding = ' ' * max(1, WIDTH - len(file_label) - test_width - code_width)
                    print(f"{file_label}{padding}{test_str:>{test_width}}{code_str:>{code_width}}")
                else:
                    code_str = format_val(stats.get('code', 0))
                    padding = ' ' * max(1, WIDTH - len(file_label) - code_width)
                    print(f"{file_label}{padding}{code_str:>{code_width}}")
        
        elif (files_only[path]['code'] > 0 or files_only[path].get('test',0) > 0) and any(p.parent == path for p in display_paths):
            file_line_label = f"{indent}    *.*"
            if with_tests:
                test_str = format_val(files_only[path].get('test', 0))
                code_str = format_val(files_only[path].get('code', 0))
                padding = ' ' * max(1, WIDTH - len(file_line_label) - test_width - code_width)
                print(f"{file_line_label}{padding}{test_str:>{test_width}}{code_str:>{code_width}}")
            else:
                code_str = format_val(files_only[path].get('code', 0))
                padding = ' ' * max(1, WIDTH - len(file_line_label) - code_width)
                print(f"{file_line_label}{padding}{code_str:>{code_width}}")

    print(separator)
    total_label = "TOTAL"
    total_code = sum(lang_stats[language]['code'] for lang_stats in dir_stats.values() if language in lang_stats)
    
    if with_tests:
        total_tests = sum(lang_stats[language]['test'] for lang_stats in dir_stats.values() if language in lang_stats)
        test_str = format_val(total_tests)
        code_str = format_val(total_code)
        padding = ' ' * max(1, WIDTH - len(total_label) - test_width - code_width)
        line = f"{total_label}{padding}{test_str:>{test_width}}{code_str:>{code_width}}"
    else:
        code_str = format_val(total_code)
        padding = ' ' * max(1, WIDTH - len(total_label) - code_width)
        line = f"{total_label}{padding}{code_str:>{code_width}}"

    if output_mode == 'rich':
        print(f"\033[1m{line}\033[0m")
    else:
        print(line)
        
    print(separator)


def main():
    """Main entry point."""
    parser = argparse.ArgumentParser(
        description="A friendly wrapper for `tokei` to summarize lines of code.",
        formatter_class=argparse.RawTextHelpFormatter
    )
    parser.add_argument(
        "path",
        nargs="?",
        default=".",
        help="The directory or file to analyze. Defaults to the current directory.",
    )
    parser.add_argument(
        "--tree",
        action="store_true",
        help="Display the full recursive directory tree.",
    )
    parser.add_argument(
        "--with-files",
        action="store_true",
        help="Show individual file counts within each package.",
    )
    parser.add_argument(
        "--with-tests",
        action="store_true",
        help="Include test files in the output, shown in a separate column.",
    )
    parser.add_argument(
        "-l", "--lang", "--language",
        dest="language",
        help="Specify the language to count (e.g., Python, py, Go, rs).",
    )
    parser.add_argument(
        "--output",
        choices=["plain", "rich", "auto"],
        default="auto",
        help="Set output mode: 'rich' for color, 'plain' for no color, 'auto' to detect.",
    )
    args = parser.parse_args()

    output_mode = args.output
    if output_mode == "auto":
        output_mode = "rich" if sys.stdout.isatty() else "plain"

    target_path = Path(args.path).expanduser().resolve()
    if not target_path.exists():
        die(f"Path does not exist: {target_path}")

    json_data = run_tokei(target_path)
    dir_stats, file_stats = parse_and_filter_tokei(json_data, target_path, args.with_tests)
    
    if not dir_stats:
        print("No code found matching the criteria.")
        return

    language = determine_language(dir_stats, args.language)
    if language == "N/A":
        print("No code found for the specified language or in general.")
        return

    print(f"\nShowing results for: {language}\n")
    
    format_output(dir_stats, file_stats, language, target_path, args.tree, args.with_files, args.with_tests, output_mode)


if __name__ == "__main__":
    main()
