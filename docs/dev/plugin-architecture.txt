Plugin System: Extensible Tree Enhancement Architecture

The plugin system provides a framework for extending treex functionality without
modifying core code. Plugins can contribute data to nodes, register CLI flags,
and filter tree output based on their analysis.

1. Architecture Overview

   The plugin system operates in six phases within the tree building process:

   Phase 1-3: Core tree building (path collection, filtering, construction)
   Phase 4: Plugin filtering (filter tree based on plugin categories)
   Phase 5: Plugin processing and integration (legacy - now Phase 4)
   Phase 6: Data enrichment (enrich surviving nodes with plugin data)

   Each plugin independently analyzes the filesystem and contributes:
   - Data attached to tree nodes
   - CLI flags for user control
   - Filtering logic based on analysis results

   Design Principles:

   - Decoupled: Plugins operate independently of core tree logic
   - Self-Contained: Each plugin manages its own data and behavior
   - Extensible: New plugins can be added without core changes
   - Consistent: All plugins follow the same integration patterns

2. Plugin Interface

   Plugins implement interfaces providing core capabilities:

   Base Plugin Interface:
   - Name() returns plugin identifier
   - FindRoots() locates directories relevant to the plugin
   - ProcessRoot() examines files and categorizes them

   FilterPlugin Interface (extends Plugin):
   - GetCategories() returns available filter categories for CLI generation

   DataPlugin Interface (extends Plugin):
   - EnrichNode() attaches data to individual nodes after filtering

   CachedDataPlugin Interface (extends DataPlugin):
   - EnrichNodeWithCache() uses cached data from filtering phase for efficiency
   - Prevents redundant expensive operations for plugins doing both filtering and enrichment

   The plugin returns categorized file lists rather than modifying trees directly.
   This separation allows the core system to handle tree structure while plugins
   focus on domain-specific analysis.

3. Data Attachment

   Node Structure Enhancement:

   Instead of hardcoded fields like Annotation, nodes contain a generic Data map:

       Data map[string]interface{}

   Each plugin stores its data under its own namespace:
   - "info": annotation data
   - "git": version control status  
   - "npm": package information

   This approach removes coupling between core types and specific plugins while
   allowing rich metadata attachment.

4. CLI Flag Registration

   Dynamic Flag System:

   The CLI introspects FilterPlugin implementations and automatically generates flags
   using the pattern: --<plugin-name>-<category-name>

   Examples:
   - --info-annotated: Show only files with annotations
   - --git-staged: Show only staged files
   - --git-unstaged: Show only files with unstaged changes
   - --git-untracked: Show only untracked files

   The system automatically:
   - Discovers plugin categories via GetCategories()
   - Registers CLI flags dynamically during initialization
   - Parses flag values into PluginFilters configuration
   - Applies filtering during tree building

5. Processing Flow

   Integration Timeline:

   1. Initialization: Plugins register with the default registry via init()
   2. CLI Setup: CLI introspects plugins and generates flags dynamically
   3. Flag Parsing: User flags are parsed into PluginFilters configuration
   4. Tree Building: Core phases 1-3 build the basic tree structure
   5. Phase 4 - Plugin Filtering: Active plugin filters process and filter tree,
      optionally storing computed data in Result.Cache for later reuse
   6. Phase 6 - Data Enrichment: DataPlugins enrich surviving nodes with metadata,
      using cached data when available via CachedDataPlugin interface

   Plugin results flow through the system as structured data, allowing the core
   to handle tree manipulation while plugins provide domain expertise.

   Performance Caching:

   The system includes a generic caching mechanism for plugins that implement both
   filtering and data enrichment:
   - Result.Cache stores arbitrary plugin data during filtering phase
   - Treex core passes cached results to enrichment phase without interpretation
   - CachedDataPlugin interface allows plugins to reuse expensive computations
   - Eliminates O(N*M) performance issues from repeated filesystem operations

6. Configuration

   Plugin Behavior Control:

   TreeConfig contains plugin-specific configuration derived from CLI flags:

       PluginFilters map[string]map[string]bool // plugin -> category -> enabled

   Example configuration from flags --git-staged --info-annotated:
   {
     "git": {"staged": true},
     "info": {"annotated": true}
   }

   This allows the tree building pipeline to apply plugin filters without
   the core system needing plugin-specific knowledge.

7. Filtering Logic

   Tree Visibility Rules:

   When plugin filters are active, nodes are included based on:
   - Core filtering rules (patterns, depth, hidden files)
   - Plugin-specific inclusion rules
   - Parent-child relationship preservation

   The system ensures structural integrity while respecting plugin decisions.
   If a plugin excludes a directory but includes a child file, the directory
   remains visible to maintain tree structure.

8. Error Handling

   Graceful Degradation:

   Plugin failures do not prevent tree building. The system:
   - Continues processing other plugins if one fails
   - Reports plugin errors separately from core errors
   - Provides partial results when possible

   This ensures that treex remains functional even with problematic plugins.

9. Extensibility

   Adding New Plugins:

   New plugins require only:
   - Implementation of the Plugin interface
   - Registration with the default registry
   - No core code changes

   The plugin system automatically integrates new plugins into CLI flag
   registration, processing pipelines, and filtering logic.

10. Migration Strategy

    Decoupling Implementation:

    The transition from hardcoded features to plugins follows a staged approach:
    - Add generic Data field alongside existing fields
    - Migrate existing functionality to use Data storage
    - Remove hardcoded fields once migration is complete
    - Update all references to use the plugin system

    This ensures backward compatibility during the transition while enabling
    future extensibility.