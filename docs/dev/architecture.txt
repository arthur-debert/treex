Tree Building Architecture

The tree building process uses a six-phase pipeline:

1. Pattern Matching - Compile exclusion patterns into composite filter
2. Path Collection - Walk filesystem with early pruning
3. Tree Construction - Build node tree from paths
4. Plugin Filtering - Apply filter plugins to categorize files
5. User Queries - Filter by file attributes
6. Data Enrichment - Attach plugin data to remaining nodes

Each phase operates on different data representations optimized for its task.

1. Pattern Matching

  All patterns use gitignore-compatible syntax via doublestar library.
  This includes:
  - User excludes (-e patterns)
  - .gitignore file contents
  - Hidden files (represented as pattern ".*")
  
  These are combined into a composite filter that can evaluate any path.

2. Path Collection Phase

  Use filepath.WalkDir with composite filter for early pruning:
  - Skip directories that match exclusion patterns
  - Skip directories beyond maxDepth
  - Collect all non-excluded paths in single traversal
  
  Output: List of file paths (not tree structure yet)


3. Tree Construction Phase

  Build tree structure from collected paths:
  - Create nodes for each path
  - Establish parent-child relationships
  - Single pass through sorted paths
  
  This is a fast in-memory operation that can be parallelized if needed.

4. Plugin Filtering Phase

  Filter plugins categorize files into named categories for visibility control:
  
  FilterPlugin interface:
  - GetCategories() returns static list of available filter categories
  - FindRoots() discovers relevant roots (e.g., .git directories)  
  - ProcessRoot() returns categorized file lists for filtering
  
  Example - Git plugin:
  - GetCategories() returns ["staged", "modified", "untracked"]
  - FindRoots() uses filepath.Glob("**/.git")
  - ProcessRoot() returns Categories map with file lists per category
  
  Plugin execution:
  1. At registration: discover plugin categories for CLI flag generation
  2. At runtime: each plugin finds its roots and processes them
  3. For each root, get categorized file lists via ProcessRoot()
  4. Apply enabled category filters to determine final tree visibility
  
  Filter plugins only deal with file categorization, not tree manipulation.

5. User Query Phase

  Attribute-based filtering on the final tree:
  
  Query syntax: --size-gt=10MB --modified-lt=1week
  
  Process:
  - Parse queries into predicates
  - Walk tree and evaluate each node
  - Remove nodes that don't match
  
  Supported attributes: size, modified time, permissions

6. Data Enrichment Phase

  Data plugins attach additional information to nodes after filtering:
  
  DataPlugin interface:
  - EnrichNode(fs, node) attaches plugin-specific data to individual nodes
  - Called only for nodes that survived filtering phases
  - Stores data in node.Data[pluginName] for rendering consumption
  
  Example - Info plugin:
  - EnrichNode() reads .info files and attaches annotation text
  - Data stored as node.Data["info"] = annotation object
  - Only processes nodes that weren't filtered out
  
  Plugin execution:
  1. After filtering but before rendering
  2. For each remaining node in the tree
  3. Call EnrichNode() for all registered data plugins
  4. Plugins attach their data to node.Data[pluginName]
  
  Efficiency: expensive operations only run on files that will be displayed.

Implementation Notes

Parallelization:
- Path collection phase is sequential (I/O bound)
- Tree construction can be parallel (CPU bound)
- Plugin execution can be parallel per root
- Start simple, optimize based on profiling

Pattern Matching:
- Use github.com/bmatcuk/doublestar/v4 for gitignore compatibility
- Patterns are evaluated during WalkDir for early pruning

Error Handling:
- Permission errors during walk: log and continue
- Missing .gitignore: ignore silently
- Plugin failures: log and continue

Future Considerations:
- Directory-based queries (e.g., dir-file-count-gte=200)
- Symlink handling (currently: don't follow)
- Caching for repeated operations

Annotations:
- Implemented as a plugin
- .info files create annotations on parent directories
- Filter options: --annotated, --non-annotated




