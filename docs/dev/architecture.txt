Tree Building Architecture

The tree building process uses a five-phase pipeline:

1. Pattern Matching - Compile exclusion patterns into composite filter
2. Path Collection - Walk filesystem with early pruning
3. Tree Construction - Build node tree from paths
4. Plugin Filtering - Apply git, annotation, and other filters
5. User Queries - Filter by file attributes

Each phase operates on different data representations optimized for its task.

1. Pattern Matching

  All patterns use gitignore-compatible syntax via doublestar library.
  This includes:
  - User excludes (-e patterns)
  - .gitignore file contents
  - Hidden files (represented as pattern ".*")
  
  These are combined into a composite filter that can evaluate any path.

2. Path Collection Phase

  Use filepath.WalkDir with composite filter for early pruning:
  - Skip directories that match exclusion patterns
  - Skip directories beyond maxDepth
  - Collect all non-excluded paths in single traversal
  
  Output: List of file paths (not tree structure yet)


3. Tree Construction Phase

  Build tree structure from collected paths:
  - Create nodes for each path
  - Establish parent-child relationships
  - Single pass through sorted paths
  
  This is a fast in-memory operation that can be parallelized if needed.

4. Plugin Filtering Phase

  Plugins operate on file lists, not tree structures:
  
  Plugin interface:
  - FindRoots() []string - returns relevant roots (e.g., .git directories)
  - GetFiles(root string, filter string) []string - returns filtered file list
  
  Example - Git plugin:
  - FindRoots() uses filepath.Glob("**/.git")
  - GetFiles() returns staged/modified files using go-git library
  
  Plugin execution:
  1. Each plugin finds its roots
  2. For each root, get filtered file lists
  3. Combine lists using set operations
  4. Remove/mark nodes based on plugin results
  
  Plugins remain simple - they only deal with paths, not tree traversal.

5. User Query Phase

  Attribute-based filtering on the final tree:
  
  Query syntax: --size-gt=10MB --modified-lt=1week
  
  Process:
  - Parse queries into predicates
  - Walk tree and evaluate each node
  - Remove nodes that don't match
  
  Supported attributes: size, modified time, permissions

Implementation Notes

Parallelization:
- Path collection phase is sequential (I/O bound)
- Tree construction can be parallel (CPU bound)
- Plugin execution can be parallel per root
- Start simple, optimize based on profiling

Pattern Matching:
- Use github.com/bmatcuk/doublestar/v4 for gitignore compatibility
- Patterns are evaluated during WalkDir for early pruning

Error Handling:
- Permission errors during walk: log and continue
- Missing .gitignore: ignore silently
- Plugin failures: log and continue

Future Considerations:
- Directory-based queries (e.g., dir-file-count-gte=200)
- Symlink handling (currently: don't follow)
- Caching for repeated operations

Annotations:
- Implemented as a plugin
- .info files create annotations on parent directories
- Filter options: --annotated, --non-annotated




