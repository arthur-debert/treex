The New Architecture: A Multi-Phase Approach

The new design breaks the tree-building process into several
distinct, sequential phases.

One particular feature of treex is a highly flexible and layered filtering mechanism , which includes: 
- Directories vs Files
- Show hidden (starts with .)
- Excludes pattern lists
- IgnoreFiels (like .gitignore)
- PluginFilters (thinks like git status or annotations ,more on this bellow)
- User supplied queries (date, size filters and more)

1. The Set-Based Filtering Model

  The core idea is to treat every list of files as a mathematical set and then
  use set operations (union, intersection, difference) to arrive at the final
  result.

  Additionally, the goal is to filter as much as possible from the early stages as those compound and prune entire trees to be processed.

  A. Exclusion Merging

    We want to merge Excludes (as in -e or --excludes, that is user supplied patterns) IgnoreFiles content (like .gitignore, which will be on by default) and hidden files. By merging them we can make one master file system search, pruning as much 
    (see ./options.txt for the actual filters) 
  B. Candiate Tree

    Directories are limited by depth-max( default: 3) , the file depth them selves. 
    With the root path + merged exlucdes  + limits we'll generate  a list of directoryes to be processed..

    This should be done through one call, leveraging the highly optimized go/unix file finding, instead of manually iterating dirs.
    We should keep tabs of the merged exludes we consumed (that are actual dirs). 
    If all items passed to excludes and in .gitignore are directories we skip Path-base filters.

    This should output a list of directories paths's not a node tree, in memory


C. The Tree
   
   If we have more path related excludion to do (since we kept tab of the ones consumed ) we still need to do path by path checks.  For each path, if no pattern in merged excludes maches, we keep the files, else we 

  This should be done for each directory, not recursively, which allows us to paralelize the task .

  For each file in the directory we will see if the name matches the merged exclude list.

  This should return a list of Nodes (which the orchestrator will turn into a node tree).
  At this point we've got-an actual tree with all nodes gone path filteriing.

D. Plugin Filtering

  Treex will have an extensible plugin system. To illustrate this I'll use git as the real world exmaple. A plugin defines: 
    - The filters it cares abouts (each has name and if is it a include or exclude filter)
  . - provides a functin that returns all inner roots it cares about (think .git dis)
  - provides a processInnerRoot(filenames(list), filterValues)
  - returns the list of files to remove or keep

  This is done with flat lists of file names, as most such tools will output a list of files. This frees plugins from tee traversal, but also makes the next steps very efficient. 
  
  The orchestrator will iterate through active plugins (which is decided no the active filters). 
  For each plugin: 
    gets list of inner root
    for each inner root
      runs processDirectory and retricves the keep/remove list
  It merge keep lists in one list, and remove lists in others.

  Then we can output the tree as a flat set of paths, and using set functions (subtract, union) get a list of active paths , which we now can find in the node tree, removing all non matching nodes by path.

E. User Queries Filtering
  treex will allow user do run queries as : 

  $ treex -q --size-gt=10MB --data-modified-lt=1week 

  That is a product of attribute (size, data created , modified, permissios, etc) and an operator (eq, gt, not not _in, etc)
  This will be parsed and translated  into a structured query, from which we wil build a function that combines all of them.
  We will now loop through nodes shoudRemove(node) and removing if needed.

2. Notes

  This is a tentative approach, subject to change. For brevity and simplicity sake we have not address: 

  2.a. Directory Base User Queries
    
    As in  --dir-file-count-gte=200. This will not be supportted at first. When it is, you do want to introduce a new step between B and C, which filters the candidte dir tree, forgoing per files iteration on directories pruned by such queries.
  
  2.b. Paralelization
    
    This does not touches the paralelization strategy. 
    
    Note that from step C onwards there are various axis for paralization (each plugin's root note, each dir, etc). We will iterate on this , but we are aiming at nderstendability at first. We don't want to commit to a hard to reason design until we have a simpler design working .

    We need to balance cpu vs dis acess (most of these are very cheap on processing but disk will be the bottleneck). Do we execute better by running bigger disk operations or many small ones, not sure. 

2. c. The UI

    While we mention cli optinons we will not do any shell related work for now. The tree building is 97% of the functionality and it can be done totally on pure go and logic, only pluging in the cli later (basically parsing optins into objects and rendering the final tree)

2.d. Performance , Ordering

  These are initial ideas. I'm really not sure if we should user plugin merge first or later.

3. Annotations

  The reason d√©tre for treex, is actually a file annotation system, through .info files. 
  That howver, is a very simple part of the problem, and the filtering is way more complex. 
  With the above design, annotations will be a plugin , as git (so one can filter --anotatted)




